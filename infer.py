r"""Compute mock data for a table.

SQLite3 types are supported (blobs are in hex):
>>> s = Schema("Table", [Column("bytes", "BLOB", None),
...                      Column("int", "INTEGER", None),
...                      Column("float", "REAL", None),
...                      Column("str", "TEXT", None)])
>>> r = {"bytes": "cafebabe", "int": "1", "float": "1.5", "str": "cafebabe"}
>>> rs_, _ = expand(s, [r], {})
>>> rs_ == [{"bytes": b"\xca\xfe\xba\xbe", "int": 1, "float": 1.5, "str": "cafebabe"}]
True

Placeholders like ``:identifier`` are expanded into distinct values:
>>> rs = [{"int": ":a"}, {"int": ":a"}, {"int": ":b"}]
>>> [a, b, c], p = expand(s, rs, {})
>>> len(p.values()) == len(set(p.values()))
True
>>> a["int"] == b["int"]
True
>>> a["int"] == c["int"]
False

Missing columns are filled in:
>>> r = {"int": "1"}
>>> [a], _ = expand(s, [r], {})
>>> a.keys() ^ {"bytes", "int", "float", "str"}
set()

Foreign keys cause other tables to require mocking:
>>> c = Schema("Country", [Column("code", "TEXT", None),
...                        Column("name", "TEXT", None)])
>>> u = Schema("User", [Column("name", "TEXT", None),
...                     Column("country", "TEXT", Reference(c, "code"))])
>>> ur = {"name": "Bob", "country": "GB"}
>>> rs, _ = references({u: [ur], c: []}, {})
>>> [a] = rs[c]
>>> a["code"]
'GB'
>>> "name" in a
True

Rows generated by mocking a foreign key can generate rows themselves:
>>> o = Schema("Order", [Column("id", "INT", None),
...                      Column("user", "TEXT", Reference(u, "name"))])
>>> or_ = {"id": 1, "user": "Bob"}
>>> rs, _ = references({o: [or_], u: [], c: []}, {})
>>> len(rs[c])
1
"""
import collections
import re

isplaceholder = re.compile(r"^:[a-z_][a-z0-9_]*$").match

Schema = collections.namedtuple("Schema", "table columns")
Schema.__hash__ = object.__hash__ # TODO: This better (columns is not hashable).
# TODO: Nullable.
# TODO: Check constraints.
Column = collections.namedtuple("Column", "name type references")
Reference = collections.namedtuple("Reference", "table column")

cast = {
    "BLOB": lambda s: bytes(bytearray.fromhex(s)),
    "INTEGER": int,
    "REAL": float,
    "TEXT": str,
}

# TODO: Construct more interesting values.
construct = {
    "BLOB": lambda i: b"\x00" * i,
    "INTEGER": lambda i: i,
    "REAL": lambda i: float(i),
    "TEXT": lambda i: " " * i,
}

# TODO: Take DB instead of schema.
#       For SQLite we have SELECT sql FROM sqlite_master WHERE name='table';
# TODO: Take existing DB rows (note given SELECT we need to truncate the table).
# TODO: Return bound placeholders.
def expand(schema, rows, placeholders):
    placeholders = placeholders.copy()
    rows_ = []
    for row in rows:
        row_ = {}
        for column in schema.columns:
            try:
                value = row[column.name]
            except KeyError:
                # TODO: Prefer the default, or NULL if nullable.
                # TODO: Provide a QuickCheck-like mode where these vary
                #       randomly. The values should not affect the test.
                row_[column.name] = construct[column.type](0)
            else:
                if isplaceholder(value):
                    if value not in placeholders:
                        placeholders[value] = construct[column.type](len(placeholders))
                    row_[column.name] = placeholders[value]
                else:
                    row_[column.name] = cast[column.type](value)
        rows_.append(row_)
    return rows_, placeholders

def references(partial, placeholders):
    inferred = {t: [] for t in partial}
    # TODO: Composite keys.
    # TODO: Rows should be map of primary key to other values.
    # TODO: Do `expand` on `rows`?
    for table, rows in partial.items():
        foreign_keys = [c for c in table.columns if c.references]
        for row in rows:
            for column in foreign_keys:
                value = row[column.name]

                # NULL doesn't have a referee.
                if value is None: continue

                # Does the referee exist?
                # FIXME: O(n²)
                if (all(r[column.references.column] != value for r in partial[column.references.table]) and
                    all(r[column.references.column] != value for r in inferred[column.references.table])):
                    inferred[column.references.table].append({column.references.column: value})

    if any(inferred.values()):
        for table, rows in inferred.items():
            inferred[table], placeholders = expand(table, rows, placeholders)
        for table, rows in references(inferred, placeholders)[0].items():
            for row in rows:
                # FIXME: O(n²)
                if all(r != row for r in inferred[table]):
                    inferred[table].append(row)

    return {t: rs + inferred[t] for t, rs in partial.items()}, placeholders

if __name__ == "__main__":
    import doctest
    doctest.testmod(optionflags=doctest.ELLIPSIS |
                                doctest.NORMALIZE_WHITESPACE |
                                doctest.REPORT_NDIFF)
